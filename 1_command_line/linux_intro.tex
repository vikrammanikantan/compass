%\dCcumentclass[aps,prd,superscriptaddress,twocolumn,floatfix,showpacs]{revtex4}
\documentclass[aps,showpacs,prd,notitlepage,preprintnumbers,amsmath,amssymb,letterpaper]{revtex4}
%\documentclass[aps,showpacs,prd,preprintnumbers,amsmath,amssymb,letterpaper]{revtex4-1}
\newcommand{\pd}[2]{ {\frac{ \partial {#1}}{ \partial {#2}} } }
\newcommand{\pdd}[2]{ { \frac{\partial^2 {#1}}{\partial {#2}^2} } }
\newcommand{\pddd}[3]{ { \frac{\partial^2 {#1}}{\partial {#2} \partial {#3}} } }
\newcommand{\pdddd}[4]{ { \frac{\partial^3 {#1}}{\partial {#2} \partial {#3} \partial {#4}}} }
\newcommand{\pddddd}[5]{ { \frac{\partial^4 {#1}}{\partial {#2} \partial {#3} \partial {#4} \partial {#5}}} }
\newcommand{\pdddddd}[6]{ { \frac{\partial^5 {#1}}{\partial {#2} \partial {#3} \partial {#4} \partial {#5} \partial {#6}}} }
%\newcommand{\beq}{\begin{equation}}
%\newcommand{\eeq}{\end{equation}}
\newcommand{\beqn}{\begin{eqnarray}}
\newcommand{\eeqn}{\end{eqnarray}}

\def\half{\frac{1}{2}}
\def\ptl{\partial}
\def\araa{Ann. Rev. Astron. Astrop.}
\def\beqar{\begin{eqnarray}}
\def\eeqar{\end{eqnarray}}
%\newcommand{\llabel}[1]{\label{#1}{\bf #1~~~~}}   % show equation label
\newcommand{\llabel}[1]{\label{#1}}              % DO NOT show equation label

\newcommand{\labeq}[2]{ \begin{equation} \llabel{#1}
{#2}
\end{equation}}


\newcommand{\beq}{\begin{equation}}
\newcommand{\eeq}{\end{equation}}
\newcommand{\calX}{\mathcal{X}}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{epsf}
\usepackage{amsmath}
\usepackage{graphics,epsfig,placeins,subfigure,wrapfig}
\usepackage{enumitem}
%\bibliographystyle{apsrev}
%\bibliographystyle{ieeetr}
%\shorttitle{WHITE DWARF-NEUTRON STAR BINARIES}
% \shortauthors{...}


\begin{document}
%%%%%%%%%%%%%%%%%%%%
% Title
%%%%%%%%%%%%%%%%%%%%
\title{COMPASS Introduction to the LINUX Command Line}
%%%%%%%%%%%%%%%%%%%%
% Author
%%%%%%%%%%%%%%%%%%%%
\author{Vasileios Paschalidis${}^1$, Erik Wessel${}^2$}                           
%
%%%%%%%%%%%%%%%%%%%%
% Address           
%%%%%%%%%%%%%%%%%%%%
\affiliation{
  ${}^1$ Departments of Astronomy \& Physics, University of Arizona, Tucson
  ${}^2$ Department of Physics, University of Arizona, Tucson
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  This note provides a basic introduction to the terminal interface of the LINUX operating system. Through the terminal we will interact with the bash shell, and gain familiarity with many useful command line tools that can be accessed through it.
\end{abstract}

\maketitle

\section{Why learn about the LINUX command line?}
Why are we insisitng on starting this workshop by forcing those of you on Windows to install LINUX?
Even stranger, why are we making you learn to use LINUX through text commands that harken back to the phospherescent tele-type consoles of the Cold War era?

As it turns out, there are fundamental reasons why using a text-based interface like the one we are teaching you today is still a useful computing skill, and will remain one into the future.
In addition, familiarty with LINUX is very beneficial, even if you keep using Windows most of the time.

To explain why, I need to establish a few basic concepts.
\subsection{Operating System Terminology}
With practically no exceptions, every modern computer has an \textit{operating system} (OS).
This is a system of software components that allow users and programs to interact with the computer, obtaining resources and using them in ways allowed by the system.
An operating system consists of a core program called the operating system \textit{kernel}, and a supporting cast of \textit{utilities}, \textit{drivers}, and \textit{system libraries}:
\begin{itemize}
  \item The kernel runs constantly and is responsible for the core functionality of the OS:\@
        \begin{itemize}
          \item Allocating and managing resources.
          \item Scheduling when other programs can run.
          \item Controlling user permissions.
        \end{itemize}
  \item Utilities are a bunch of additional programs that come bundled with the OS and do specific things not handled by the kernel.
  \item Drivers are pieces of software that allow the computer to talk to other equipment like displays and keyboards.
  \item System libraries contain the code for performing many common computations in this specific system. This allows programs to work on different systems than the ones they were originally written on
\end{itemize}
\subsection{UNIX}
It turns out that not all ways of designing an operating system are equally effective: there are some ideas that work well, and others that cause problems.
In the early 70's UNIX was released, and it quickly gained popularity as a particularly well-designed operating system.
The more people who used UNIX, the more software was written to work on UNIX-like systems, eventually leading many other OSs to implement the basic behavior of UNIX systems.

One of the many UNIX-like operating systems to be developed was NeXTSTEP, which eventually became the basis modern version of macOS.
But the first UNIX-like operating system that could be downloaded, used for free, and modified by anyone was LINUX.
\subsection{LINUX}
LINUX was developed as a personal project of Linus Torvalds while he was a student at the University of Helsinki, as a result of his frustration with the licensing constraints on other UNIX-like OSs.
It was released in 1991, and as the first totally free UNIX-like OS it took off quickly.

Today, there are many different versions of LINUX, called LINUX \textit{distributions} or \textit{distros} for short.
These all feature the same LINUX kernel (with only slight modifications), but differ in the collections of utilities, drivers, and system libraries they come packaged with.

Places where you will find LINUX include:
\begin{itemize}
  \item Many personal computers in the form of easy-to-use distros like Ubuntu.
  \item Most mobile and wearable devices in the form of the Android OS, which is a variant of LINUX.
  \item Nearly every high-performance computing cluster.
  \item Nearly every internet server and cloud-computing cluster.
\end{itemize}

\subsection{Terminals and Shells}
Terminals are a completely text-based method of interacting with a computer.
Despite the fact that they are one of the oldest ways to use a computer, terminals remain with us today
due in part to their extreme simplicity, and in part to the impressive capability of shell interfaces.

A shell is a program that interprets user input in real time.
Shells provide a computer language that they interpret in real time, allowing you to describe what you want the computer to do.
Essentially, they let you talk to a computer in a way that is easy to learn but also flexible enough to let you do almost anything.
In fact, it is very hard to develop a graphical interface that allows you to do everything that can be done with a shell.

Here's a culinary analogy: if you want to get dinner, you can go get food from a resturaunt, or cook food yourself.
If you eat out, you save yourself the trouble of learning how to cook, but you are limited by the menu options of the resturaunts in your area.
This is frustrating: even if the resturaunts around you have the ingredients and equipment to make some dish, if it doesn't appear on their menu, it isn't something you can order.
However, if you put in the effort to learn to cook for yourself, then as long as you have the ingredients, you can put them together in the way you see fit.
Similarly, while graphical user interfaces may have an easier learning curve, they are fundamentally limited: by learning a shell language and talking directly to your computer with it, you can transcend those limitations.

\section{Shell configuration}
Today, we will learn to use a popular shell called \verb|bash|.
First, open the terminal application on your machine.

\begin{itemize}[leftmargin=*,itemsep=0.05em]
\item To test whether your account is configured to the bash shell, in the
prompt type

\begin{verbatim}
echo $SHELL
\end{verbatim}

If everything is set up properly you should see

\begin{verbatim}
/bin/bash
\end{verbatim}

  \item By default, the shell will start out in your home directory.
  \item To list the content of your current directory, type:

\begin{verbatim}
ls
\end{verbatim}
  
You will see a list of all the files in your directory.

\end{itemize}

The terminal may appear daunting at first. However, Linux is full of
shortcuts and failsafes (you will learn the basics). For example, the
bash shell creates a hidden file (we will talk about hidden files
later) called \verb|.bash_history| which stores
  your previous commands so you don't have to retype them. You can
  access these by hitting the up arrow a few times. Try it now.

\section{Creating and deleting directories, and navigating}

One of the most important aspects in keeping your files organized is to learn how to create directories. This can be done with the \verb|mkdir| command.

First, to keep things organized, let's create a new directory for all the COMPASS workshop exercises we are about to do.
In the terminal, type the command

\begin{verbatim}
mkdir COMPASS2024
\end{verbatim}

Then, hit the ``Enter'' key.

Now, we'd like to move into this directory. To do this, we will need another command: \verb|cd| for ``change directory''.
To change direcotry to be inside the \verb|COMPASS2024| directory we just made, type

\begin{verbatim}
cd COMPASS2024
\end{verbatim}

and hit enter.

Now, lets make a few test directories.

\begin{verbatim}
mkdir dir1
\end{verbatim}

You can create several at the same time by typing a sequence of directory names after \verb|mkdir|

\begin{verbatim}
mkdir dir2 dir3
\end{verbatim}

In addition, we can create a whole sequence of subdirectories all at once by using the -p flag

\begin{verbatim}
mkdir -p dir4/subdir/subsubdir
\end{verbatim}

The -p flag will create not only the directory subsubdir, but also the parent directories subdir and dir3.

Go ahead and use \verb|ls| to see what is in your current directory, you should see all 4 subdirectories.

To delete an empty directory you can type

\begin{verbatim}
rmdir dir1
\end{verbatim}

``rm'' for remove, or for multiple directories at once

\begin{verbatim}
rmdir dir2 dir3
\end{verbatim}

Now try to remove \verb|dir4| the same ways

\begin{verbatim}
rmdir dir4
\end{verbatim}

Uh-oh! What happened?
If you followed the earlier steps when creating \verb|dir4| you should see an error message

\begin{verbatim}
rmdir: failed to remove ’dir4/’: Directory not empty
\end{verbatim}

This is because the \verb|rmdir| command has a very specific function: it is only for removing empty directories.
If you attempt to use it to remove anything that isn't an empty directory, it will print out an error message and refuse to do anything.

Let's use \verb|dir4| to practice naviating. To navigate into the directory, type

\begin{verbatim}
cd dir4/subdir
\end{verbatim}

Now, type

\begin{verbatim}
ls
\end{verbatim}

You will see only the \verb|subsubdir| is visible from within this folder.
Navigate into that folder with

\begin{verbatim}
cd subsubdir
\end{verbatim}

\begin{itemize}
\item One of the most
important commands is ``pwd'', which allows you to find your current
location. Type

\begin{verbatim}
pwd
\end{verbatim}

You should see something like

\begin{verbatim}
/home/USERNAME/COMPASS2024/dir4/subdir/subsubdir
\end{verbatim}

where ``USERNAME'' will be your username, while the part before that could be different on different systems. ``pwd'' stands for ``print working directory''.

Now we can see that we've fallen into a hole: how do we get out of this directory? We need to go backwards.
There are several ways to do this.
One, we could type the full path to wherever we want to go. This is done by starting the path with a \verb|/| to indicate that this path starts at the root of the filesystem, instead of starting from the current location (which is what filepaths begining with nothing imply, along with ones that begin with \verb|./|).
For example, if we wanted to get back to COMPASS2024, we could type

\begin{verbatim}
cd /home/USERNAME/COMPASS2024
\end{verbatim}

        Instead, we could use a short hand for returning to the directory one level up
\begin{verbatim}
cd ../../../
\end{verbatim}

        Yet another way to do this is to first call \verb|cd| with no filepath. This takes you to the user directory, and then you can go back into \verb|COMPASS2024| as before

\begin{verbatim}
cd
cd COMPASS2024
\end{verbatim}

        Use \verb|pwd| to make sure you're back in the \verb|COMPASS2024| folder now, as expected.

\item One of the most convenient shortcuts of linux is the
  ``tab-completion''. Which helps in writing all these long paths.
  Try again changing into the subsubdir using the absolute path

\begin{verbatim}
cd /home/USERNAME/COMPASS2024/dir4/subdir/subsubdir
\end{verbatim}

but each time you hit a letter hit the ``tab'' button a couple of
times, if the path is not auto-completed enter another letter in the
path.

\end{itemize}

\section{Commands, arguments, and strings}
The tools we've used so far: \verb|ls|, \verb|cd|, \verb|mkdir|, and \verb|rmdir|, are all \textit{commands}.
Commands are basically little programs that can be run to do very simple things.
Each command has zero or more required \textit{arguments} that are pieces of input that tell the command what to do.

For example, \verb|cd|, \verb|mkdir|, and \verb|rmdir| all take a filepath as an argument.
In fact, it turns out, \verb|ls| does to: instead of just listing the current directory, you can list the contents of any directory, for example try
\begin{verbatim}
ls dir4
\end{verbatim}

We also saw a special type of argument for \verb|mkdir| with a dash in front of it. This optional argument is called a \textit{flag}, and these typically go before the main arguments and specify settings the command should obey.
In our case, the \verb|-p| flag tells mkdir to create intermediate directories wherever it needs to.

An example of a command that doesn't take a filepath as its argument is \verb|echo|. \verb|echo| simply repeates whatever text argument it is given.
However, this argument must be given as a \textit{string}. A string is any set of characters you can type, including spaces. These are entered by surrounding them with \verb|""| so that the shell knows where they start and stop.
For example,

\begin{verbatim}
echo "Hello World"
\end{verbatim}

prints exactly that message to the Terminal.

\section{Files}

Linux is an extensionless system. It doesn't depend on the extension of
a file to tell what type of file it is. For example, a pure text file with
the extension .txt or .dat or .png or .jpg is treated as a text file in linux.

\begin{itemize}
\item Let create our first file using the ``touch'' command. Type

\begin{verbatim}
cd /home/USERNAME/COMPASS2024/dir4/subdir/subsubdir
\end{verbatim}

and

\begin{verbatim}
touch foo.txt foo1.txt foo2.txt
\end{verbatim}

This will create 3 empty files in the subsubdir directory. Strictly
speaking, touch just updates the timestamp of last access of the
files.  But, since these files never existed they are created by the
system.

Lets also write something in these files. Type

\begin{verbatim}
echo "First entry into foo file" >> foo.txt
\end{verbatim}

\begin{verbatim}
echo "First entry into foo1 file" >> foo1.txt
\end{verbatim}

\begin{verbatim}
echo "First entry into foo2 file" >> foo2.txt
\end{verbatim}

{\bf Hint: Remember to use the up arrow to access your previous
commands, so that you don't have to retype everything.}

The ``echo'' command simply prints the text in the quotes, while the
append operator ``$>>$'' just appends to the files the output from
echo, i.e., the text in the quotes.

\item We can now use the ``file'' command to figure out the file type, i.e.,
enter
  
\begin{verbatim}
file foo.txt
\end{verbatim}

and the output should be.
\begin{verbatim}
foo.txt: ASCII text
\end{verbatim}

\item When choosing file names and directory names, it is more
  convenient to not use spaces as they require special treatment. A
  better practice is to use underscores in the place of spaces, i.e.,

\begin{verbatim}
echo "First entry into foo file" >> my_fist_foo_file.txt
\end{verbatim}

\item Lets now list the contents of the subsubdir, i.e., type

\begin{verbatim}
ls 
\end{verbatim}

Much like \verb|mkdir|, it turns out \verb|ls| also has useful options to obtain more information about the files, i.e.,

\begin{verbatim}
ls -l
\end{verbatim}

which will list the files in alphabetical order and show the permissions of the files (no need to get into this for our purposes), the owner and group of the files, the size of the files in bytes (if you use the flags ``-lh'' it will print the file size in human readable form), the timestamps for the files and the filenames. We can also use a combination of options. A useful one is

\begin{verbatim}
ls -ltrh
\end{verbatim}

which lists the files in reverse order time, i.e., the item that was
accessed last appears at the bottom of the list.

\item Earlier we mentioned that Linux has hidden files. We can list
  these by using the ``-a'' or ``--all'' flag. Go to your home
  directory using \verb|cd|, and type

\begin{verbatim}
ls -a
\end{verbatim}

You should now see a number of files that start with a ``.''. All
these are hidden files. You can also see your ``.bash\_history'' file
(which contains your previous commands), as well as one of the most
important files in Linux the ``.bashrc''. The ``.bashrc'' file is
loaded every time you log into your linux account and can be used to
define useful macros, including aliases, set shell variables (like the
\$SHELL variable we used) and other useful shortcuts.


\end{itemize}

For most Linux commands there are manual pages which you can access by typing ``man'' and the command name, e.g.,

\begin{verbatim}
man ls
\end{verbatim}

In the manual pages you can read more about the command and the
different options (flags) it has. Of course the world wide web is always
your friend.

\subsection{Moving files around}

Copying files or moving them is always useful. Create a new directory in your home directory, typing

\begin{verbatim}
cd ~/COMPASS2024; mkdir dir1
\end{verbatim}

Notice that we used ``$\sim$/'', which is a shortcut to the home
directory path. We also used the semicolor ``;'' operator to separate
the cd command from the mkdir command. You can use multiple semicolons
on one line to separate multiple commands that you can execute in the
order they appear and hit enter only once. Now copy the
``my\_fist\_foo\_file.txt'' from subsubdir to the dir1
directory. Using the ``cp'' (copy) command and the paths to the files

\begin{verbatim}
cp ./dir4/subdir/subsubdir/my_fist_foo_file.txt dir1/
\end{verbatim}

The first dot ``.'' is meant to indicate that {\tt dir4} is in your working directory.
The command would be equivalent to

\begin{verbatim}
cp dir4/subdir/subsubdir/my_fist_foo_file.txt dir1/
\end{verbatim}


{\bf Remember to always use the tab completion to write the paths, so
  that you don't have to type the full path.}


The syntax of the copy command is ``cp [source] [destination]''. If you are sure
you don't want to copy the file, but move it, i.e., no longer have the file
in your source you can use the ``mv'' command, e.g.,

\begin{verbatim}
mv ./dir4/subdir/subsubdir/foo.txt ./dir4/subdir/
\end{verbatim}

Now list the contents of the subsubdir directory

\begin{verbatim}
ls ./dir4/subdir/subsubdir/
\end{verbatim}

and you should see the file you moved. Also, list the contents of subdir

\begin{verbatim}
ls ./dir4/subdir/
\end{verbatim}

and you will see the file was indeed moved. The copy command can be
used to copy directories too.

\subsection{Deleting files}
It is also possible to destroy files.
When doing this, one should be very cautious, since this action is generally not un-doable.
Instead of \verb|rmdir|, which only destroys empty directories, we can use the \verb|rm| command to destroy files and directories.

For example, if we create
\begin{verbatim}
touch test.txt
\end{verbatim}

We can destroy it by
\begin{verbatim}
rm test.txt
\end{verbatim}

By using the \verb|-r| flag, we may instead recursively destroy a whole directory tree.
Try,

\begin{verbatim}
rm -r dir1
\end{verbatim}

The directory and its file should now be gone.

\section{Grepping}

When debugging we will often need to find certain expressions in a file. Using the linux command
grep is one of the best ways to find an expression in a text, e.g.,

\begin{verbatim}
grep "First" ./dir4/subdir/foo.txt
\end{verbatim}

The syntax is ``grep expression file''. The above will search and
print all the occurences of ``First'' in the file
\verb|foo.txt|.
(Of course, in this case there is only one line in the file, so it's not much of a test.)

\verb|grep| also has a useful \verb|-r| option that allows it to recursively search through directories and run on each file.
This way, not only can you find content in files, you can find files based on what content they contain.

\begin{verbatim}
grep -r "First" ./
\end{verbatim}

\section{Tar archives}
One particularly useful utility is \verb|tar|.
This program allows you to create \textit{arcives}: collections of files and folders that can be saved as a single file, and extracted later.

The \verb|tar| command has many options, I won't go through all of them here.
But, just to get started, here's how you would turn \verb|dir4| into a \verb|tar| archive.
\begin{verbatim}
tar -cf dir4_archive.tar dir4
\end{verbatim}
The \verb|-c| flag tells \verb|tar| that it will be creating a new archive, and the \verb|-f| flag tells it that it will accept a filename for the new archive next.
Then the filename is provided, followed by the file(s) or folder(s) to be archived.
Whenever a folder is lised, it is assumed that all its contents will also be included in the archive.

To test that this worked, we need to move the archive somewhere else, so that it will not just overwrite the original files when unpacked.
Do the following
\begin{verbatim}
mkdir test
mv dir4_archive.tar test/
cd test
ls
\end{verbatim}

You should see that this folder only contains the archive file.
Now, extract the archive by executing

\begin{verbatim}
tar -xf dir4_archive.tar
\end{verbatim}
Where the \verb|-x| option tells \verb|tar| that it is time to extract the archive, and the target folder argument is no longer needed.

After this is done, running \verb|ls| will reveal that a copy of \verb|dir4| has appeard.
By inspecting it, you can confirm that all the contents of \verb|dir4| have appeared as well.

\section{More useful commands}
So far, we have mostly made folders and a few files, and navigated around, and did some searching.
But there are more things we can do.
Below are several more useful commands.

To see how much disk space a folder or file uses, use
\begin{verbatim}
du ./
\end{verbatim}
To make the output shorter, use the \verb|-s| option to only show the summary of total disk usage for everything.
And, the \verb|-h| option can be used to write the disk usage in human-readable units like Kb, Mb, and Gb, rather than in bytes.
\begin{verbatim}
du -sh ./
\end{verbatim}

To tell of two files differ, the \verb|diff| utility can be used:
\begin{verbatim}
diff dir4/subdir/subsubdir/foo1.txt dir4/subdir/subsubdir/foo2.txt
\end{verbatim}
will show a difference, whereas
\begin{verbatim}
diff dir4/subdir/foo.txt dir4/subdir/subsubdir/my_fist_foo_file.txt
\end{verbatim}
will not.

To see how many words a file contains, use \verb|wc|
\begin{verbatim}
wc -w dir4/subdir/foo.txt
\end{verbatim}
Or use the \verb|-l| option to count lines, or the \verb|-c| option to count characters (a.k.a bytes).

To launch an interactive calculator program, call
\begin{verbatim}
bc -l
\end{verbatim}
This will allow you to type expressions into a calculator and get numerical answers.
To quit, type ``quit''.

To print a list of the currently running processes in your shell, use
\begin{verbatim}
ps
\end{verbatim}

To download things from the internet, you can use the \verb|curl| utility
\begin{verbatim}
curl --output comic.png https://imgs.xkcd.com/comics/tar_2x.png
\end{verbatim}

\section{Combining commands}

As fun as this is, the real power of using these command line utilities comes from stringing them together.

For example, lets say we wanted to know how many lines the word ``First'' appears in for all the files in our directory.
We can take the output of \verb|grep|, which lists all the occurances, and use \verb|wc -l| to count how many lines there are.

To do this, we use something called \textit{piping} to send the output from one command into the first input of another command, as if that output were a file.

This is done with the $|$ symbol, like this
\begin{verbatim}
grep -r "First" dir4 | wc -l
\end{verbatim}

Another thing we can do is use commands that are designed to take other commands in their arguments.

For example, lets say we are waiting for a process to stop running, and we'd like to monitor it.
We can use a command called \verb|watch| (Note: unfortunately, watch is not installed by default on macOS) to repeatedly run \verb|ps| every few seconds so that we can keep an eye on it.
Since \verb|watch| is set up to take a command in its input, we just do
\begin{verbatim}
watch -n1 ps
\end{verbatim}

Combining commands unlocks much of the power of the shell interface, and leads eventually to shell scripting, which is a topic we will cover tomorrow.

\section{Wildcards}
So far, we have written out filepaths explicitly. However, there are many times when you may want to write a long list of files that follow some pattern, without having to do so manually.
For situations like this, we can use \textit{wildcards}. Wildcards are characters in a filepath that essentially mean ``anything goes here''

For example, go to the following directory
\begin{verbatim}
cd /home/USERNAME/COMPASS2024/dir4/subdir/subsubdir
\end{verbatim}
In this directory, we could type \verb|ls| to list all the files.
But, we could also just list the files that obey the pattern ``foo<number>.txt''.
To do this, we use the \verb|?| wildcard, which means any character can go there

\begin{verbatim}
ls foo?.txt
\end{verbatim}
There is also the \verb|*| wildcard, which stands for ``any string goes here''.
This can substitute a string of any length.

For example, we could list all the .txt files
\begin{verbatim}
ls *.txt
\end{verbatim}
Which, of course, are all the files in the directory in this case.

It is also possible to use brackets to specify specific character ranges, for example
\begin{verbatim}
ls */out_[2-5].pdb
\end{verbatim}

Give this a try to list out only certain types of files on your home directory!

\section{Reading files}

Linux has a number of tools to read files

\begin{itemize}

\item Cat $<$file$>$

  cat stands for concatenate. It will print the entire file in one go on your screen. Good for files
  that are only a few lines long.

\item less $<$file$>$

  It will print the file in pages that you can browse through using the up/down arrows or the up/down
  page keys. Type ``Q'' to exit.

\item head -nA $<$file$>$

  Here A is a integer number. The command print on screen the first A lines of the file

\item tail -nA $<$file$>$

Here A is a integer number. The command print the last A lines of the file.

\end{itemize}

\section{More challenges!!}
Have you gotten this far! Great! In that case, it's a good idea to keep practicing.
At the following link you will find a GitHub repository with extra fun challenge exercises on it. Download the files and then follow the instructions in the README.txt''
\url{https://github.com/mssalvatore/command-line-challenges}

Have fun!

\section{Editors}

One of the most important tools in building our programs are text
editors.  Almost all Linux distributions these days have vi, vim and
the emacs editors.  Here we have written a quick guide to vi and vim, and emacs, so that you can get started using either.

\subsection{Vi/vim}
First of all, you need to check what is installed on your system. You might have vim, or just vi. Fortunately, the usage of these two is almost the same.

To check what is set up, we can use the \verb|which| command.

\begin{verbatim}
which vim
\end{verbatim}

If you see a filepath to the \verb|vim| executable, then you can use \verb|vim|. If not, you will probably have to use \verb|vi| instead, in place of most of the commands below. There also may be slight differences, which we will handle if they arise.

To launch \verb|vim| call it with the path to a file you want to edit or create
\begin{verbatim}
vim my_test_file.txt
\end{verbatim}

You will see your terminal be taken over by the \verb|vim| text editor.
This editor is entirely text-based: it runs completely within the terminal interface and doesn't require any graphical elements or interface to be set up.
Because of this, \verb|vim| and \verb|vi| are installed on almost every system, and are a frequent go-to when trying to read and edit files over terminal and ssh interaces, when you don't have a chance to set up a more complicated and full-featured editor.

It would be nice to populate this blank file with some text.
But you may notice: your keys aren't doing what you expect!
The reason is that, in the default mode, keys in vim are reserved for doing commands, such as to navigate the file, select text, and change modes.

In order to edit the file, we need to activate the \textit{insert} text mode, which we can do by pressing the \verb|i| key.

Once in insert mode, you will be able to type normally. Go ahead and type a long sentence, such as,

\begin{verbatim}
Speak the speech, I pray you, as I pronounc'd it to you, trippingly on the tongue.
But if you mouth it, as many of our players do, I had as live the town crier spoke my lines.
Nor do not saw the air too much with your hand, thus, but use all gently; for in the very torrent, tempest, and (as I may say) whirlwind of your passion, you must acquire and beget a temperance that may give it smoothness.
O, it offends me to the soul to hear a robustious periwig-pated fellow tear a passion to tatters, to very rags, to split the cars of the groundlings, who (for the most part) are capable of nothing but inexplicable dumb shows and noise.
I would have such a fellow whipp'd for o'erdoing Termagant.
It out-herods Herod. Pray you avoid it.
\end{verbatim}

The downside of insert mode is that you can't run any commands!
To exit insert mode, hit the \verb|ESC| key.

Now we have a good amount of text on our file, we can practice navigating around.
To move, use the arrow keys as you normally would. You'll see the cursor moving around the text.

There are also navigational shortcuts: press \verb|$| to jump to the end of a line, and \verb|^| to jump to the beginning.

You can also use \verb|w| to jump to the next word, and \verb|b| to jump to the previous.

To go to the very end of the file, you can press capital G \verb|shift+G|.

You can also jump to a specific line with \verb|:<line number>|

To select text, you can press \verb|v| to enter visual mode: here, moving your cursor will select text just like a normal text edtior.

To change the text that is selected, you can press \verb|c|, which will take you into insert mode again.

Finally, you can save by pressing \verb|:w| to ``write'' the file.

To quit \verb|vim| you will use \verb|:q|. If you try to quit without saving, you'll get an error. To quit anyway, use \verb|:q!|.

I have to admit, this is only the tip of the iceburg for what vim can do. To access documentation, you can use the \verb|:help|.
The real power of vim is in the ability of stringing commands together. We may cover more on this on friday.

\subsection{emacs}
\begin{verbatim}
emacs my_fist_foo_file.txt
\end{verbatim}

You can now start to edit this file. Add a few sentences to it.
\begin{itemize}

\item To move fast between the text you can use the ``pg up'' and pg
  dn'' keys, the ``home'' and ``end'' keys, you can keep the ``ctrl''
  key pressed down while using the left, right, up and down arrows to jump
  between words and text. To move a page down you can also type

\begin{verbatim}
ctrl+v
\end{verbatim}

and to move up

\begin{verbatim}
Meta+v
\end{verbatim}

where the ``Meta'' key is typically the ``alt'' key (the key left of the space bar).

To move to the beginning of a line you can also type
\begin{verbatim}
ctrl+a
\end{verbatim}

and to the end of a line you can also type
\begin{verbatim}
ctrl+e
\end{verbatim}


These shortcuts will expedite greatly how quickly you move the cursor
through the text. If you want to go directly to the end of the text (buffer)
type

\begin{verbatim}
Meta+<
\end{verbatim}

and the beginning of the text (buffer)

\begin{verbatim}
Meta+>
\end{verbatim}

  
\item To save what you wrote type 

\begin{verbatim}
ctrl+x+s
\end{verbatim}

\item To close emacs type

\begin{verbatim}
ctrl+x+c
\end{verbatim}

\item Copying and pasting inside a file is always useful. Open the file with emacs again

\begin{verbatim}
emacs my_fist_foo_file.txt
\end{verbatim}

\item Move the cursor to the beginning of the text you would like to copy/cut and hit

\begin{verbatim}
ctrl+space
\end{verbatim}

\item This activates the marking area tool. Use the arrows to highlight the area you want to cut/copy.
To cut the text type

\begin{verbatim}
ctrl+w
\end{verbatim}

\item To copy the text type

\begin{verbatim}
Meta+w
\end{verbatim}


\item To paste the text, move the cursor where you want to paste the text and type

\begin{verbatim}
ctrl+y
\end{verbatim}

where ``y'' stands for yank.

\item To remove (kill) an entire line in your text you can type

\begin{verbatim}
ctrl+k
\end{verbatim}

\item To undo a move type

\begin{verbatim}
ctrl+_
\end{verbatim}

In other words

\begin{verbatim}
ctrl+shift+-
\end{verbatim}

To redo a move type

\begin{verbatim}
ctrl+shift+space bar+-
\end{verbatim}

While these may sound like many commands, keep in mind that practice makes perfect!
\end{itemize}




%\section{Bash Scripting}
%
%A Bash script is a plain text file which contains a series of
%commands. These commands we would normally type ouselves in the linux
%terminal (such as ls or cp for example). However, when we want to
%automate doing large batch of jobs a bash script comes in very
%handy. In addition, a bash script can execute other bash scripts, so
%you can have a hierarchy of bash scripts that accomplish specific
%tasks.
%
%It is convention to give files that are Bash scripts an extension of
%``.sh'' (myscript.sh for example), but since linux is an extensionless
%operating system, this convention does not have to be respected.
%
%Let's create our first bash script, by creating a file myscript.sh
%which simply prints ``Hello world'' on the screen. In emacs create a
%file myscript.sh with the following content
%\begin{verbatim}
%#!/bin/bash
%# My first bash script
%echo "Hello World!"
%\end{verbatim}
%and save this file.
%
%Anything that can be executed in linux must have executable permissions. To make the myscript.sh executable type
%
%\begin{verbatim}
%chmod u+x myscript.sh
%\end{verbatim}
%
%To execute the bash script run
%
%\begin{verbatim}
%./myscript.sh
%\end{verbatim}
%
%In the script the hash exclamation mark ( \#! ) character sequence
%followed by a path, tells the rest computer what interpreter (or
%program) should be used to run (or interpret) the rest of the lines in
%the text file. (For Bash scripts it will be the path to Bash, but
%there are many other types of scripts and they each have their own
%interpreter.) This must be the first line of the script (not second
%or third even if the first lines are blank).
%
%Also, the hash must be followed by the exclamation mark. Otherwise
%anything after the hash is treated as a comment. This is why the
%second line in the script ``\# My first bash script'' did not print
%anything on screen. Like when writing code, comments are extremely
%useful in a script to tell the developer and possible future
%developers what specific parts of the script are doing.
%
%\subsection{Command line arguments}
%
%Bash scripts can get arguments. The following script
%is a simple copy script, it copies file \$1 (the first argument
%in the script) to something file \$2 (second argument in the script),
%then prints ``Details for file'' using the name of file \$2, and finaly
%lists the details
%
%\begin{verbatim}
%#!/bin/bash
%# A simple copy script
%cp $1 $2
%# Let's verify the copy worked
%echo Details for file $2
%ls -lh $2
%\end{verbatim}
%
%Take the above script and put it in a file that you call ``copy.sh'', and
%save it. Make the script executable, i.e.,
%
%\begin{verbatim}
%chmod u+x copy.sh
%\end{verbatim}
%
%Create an empty file file1.txt, by running
%
%\begin{verbatim}
%touch file1.txt
%\end{verbatim}
%
%and then execute
%
%\begin{verbatim}
%./copy.sh file1.txt file2.txt
%\end{verbatim}
%
%The script should copy file1.txt to file2.txt, and then print on screen the details of file2.txt.
%
%You can add more arguments to a script which inside the script can be
%accessed through the variables \$1, \$2, \$3, up to \$9. Variable \$0
%is the name of the script. In general shell variables are treated as
%strings, but we can also do numerical calculations with them.
%
%
%\subsection{Variables}
%
%In the previous example \$1, \$2 actually represent variables whose
%values are assigned by the arguments passed to the script at execution
%time. Variables are extremely important in doing magical operations
%with linux.
%
%We can also define variables that are local to the script, and which can
%take on the values from the arguments of the script. For example, the
%previous script can also be written as
%
%\begin{verbatim}
%#!/bin/bash
%# A simple copy script
%file1=$1
%file2=$2
%cp $file1 $file2
%# Let's verify the copy worked
%echo Details for file $file2
%ls -lh $2
%\end{verbatim}
%
%The above script does the same operation as the previous script. The
%difference is that we introduced the local variables ``file1'' and
%``file2'' here, which take on the values of variables \$1, and \$2,
%respectively. Put the previous lines in a script called, e.g.,
%``copy2.sh'', make the script executable, create a file file1.txt, and
%execute the script it in the same
%
%\begin{verbatim}
%./copy.sh file1.txt file2.txt
%\end{verbatim}
%
%The result should be identical as in the case of the ``copy.sh''
%script.
%
%We can also do arithmetic computations with variables. Let's look at
%the following script.
%
%\begin{verbatim}
%#!/bin/bash
%# Basic arithmetic using double parentheses
%a=$(( 4 + 5 ))
%echo $a # 9
%
%var1=4
%var2=5
%a=$(($var1+$var2))
%echo $a # 9
%
%b=$(( $a + 3 ))
%echo $b # 12
%
%b=$(( $a + 4 ))
%echo $b # 13
%(( b++ ))
%echo $b #   14
%
%(( b += 3 ))
%echo $b # 17
%
%a=$(( var1 * var2 ))
%echo $a # 20
%
%\end{verbatim}
%
%
%One other extremely useful utility are ``for loops''. For loops have
%the general sysntax ``for (variable) in (list); do (operations);
%done''. There are many ways to set a list of values that a variable
%can obtain. Let's look at the following simple script demonstrating a
%for loop, where the variable ``i'' takes on values 0 to 5 (with unit
%increment) and prints it on screen.
%
%\begin{verbatim}
%#!/bin/bash
%# Basic for loop
%for i in `seq 0 5`
%do
%  echo $i
%done
%\end{verbatim}
%
%Put the above in a script called ``loop.sh'', make it executable and
%run it. You should see on your screen
%
%\begin{verbatim}
%0
%1
%2
%3
%4
%5
%\end{verbatim}
%
%In the above, the ```seq 0 5`'' operator creates the list of numbers 0 1 2 3 4 5
%
%Now, let's use the above tools we learned to sum the numbers from 0 to
%1000 with unit increment.
%
%\begin{verbatim}
%#!/bin/bash
%# Basic for loop for summing
%sum=0
%for i in `seq 0 1000`
%do
%  sum=$(($i+$sum))
%done
%echo "The sum from 0 to 1000 is:" $sum
%\end{verbatim}
%
%Put the above in a script called ``sum.sh'', make it executable and
%run it. You should see on your screen
%
%\begin{verbatim}
%The sum from 0 to 1000 is: 500500
%\end{verbatim}
%
%Now, let's look at a very useful application of loops. Let's first
%create 1000 files called file1.txt, file2.txt ....file1000.txt using the following script
%
%\begin{verbatim}
%#!/bin/bash
%
%for i in `seq 1 1000`
%do
%  touch file$i.txt # the strings file $i and .txt are concatenated here
%done
%ls file* # let's list the files after we have created them
%\end{verbatim}
%
%Add the above lines in a ``generate\_files.sh'' script and execute it.
%This may take a couple of seconds to finish, but you should see all
%the files you generated. Now, let's a loop to rename the files from
%file1.txt file2.txt ... to file\_1.txt file\_2.txt ..., using a cool
%linux utility called sed, and the following script
%
%\begin{verbatim}
%#!/bin/bash
%
%for i in `ls file*` # here we create a list using ls
%do
%  j=`echo $i || sed s/file/"file_"/` # echo prints the value of i and the output is piped with the pipe operatro || to sed, which then replaces the string "file" with the string "file_".
%done
%ls file* # let's list the files after we have changed their names
%\end{verbatim}
%
%With the stroke of one key and the above script we were able to rename
%1000 files. Similarly we can manipulate files, even change their
%content and parse them. We can create loops with conditionals and exit
%clauses. Your imagination is the limit, and the internet is your
%friend! The linux community is extremely supportive, and chances are
%that what you want to do, somebody else has already a bash script for
%it. Linux is an extremely powerful operating system.
%
%
%\section{Basic plotting with gnuplot}
%
%Gnuplot is linux utility for plotting data files and functions. Gnuplot
%has many intrinsic functions one can plot. To start plotting data or
%functions first we need to launch gnuplot. To do so type
%
%\begin{verbatim}
%gnuplot
%\end{verbatim}
%
%Now you will be in the gnuplot command line. To plot the $\sin(x)$ simply type
%
%\begin{verbatim}
%p sin(x)
%\end{verbatim}
%
%and hit ``enter''. To specify a range in the x axis type
%
%\begin{verbatim}
%p [-3.1415:3.1415] sin(x)
%\end{verbatim}
%
%and hit enter.  The last command plots $\sin(x)$ from $-\pi$ to
%$\pi$. You can also set log scales if you desire. For example type
%
%\begin{verbatim}
%p [0,10] x**2
%\end{verbatim}
%
%and hit enter. The operator ``**'' is the ``to the power of'' operator. So,
%this last command plots the function $f(x)=x^2$. To set the y-axis to be in log
%scale (i.e., a log-linear plot) just type
%
%\begin{verbatim}
%set log y; p [0.1:10] x**2
%\end{verbatim}
%
%Here you learned that the semicolon separates different commands. To also
%set the x-axis in log scale type
%
%\begin{verbatim}
%set log y; set log x; p [0.1:10] x**2
%\end{verbatim}
%and hit enter. You should see a straight line.
%
%We can also label the axes
%
%\begin{verbatim}
%set log y; set log x; set xlabel "x"; set ylabel "f(x)=x*x"; p [0.1:10] x**2
%\end{verbatim}
%
%Gnuplot has multiple intrinsic functions {\tt log} (natural log) {\tt
%  log10} (base 10 log), {\tt sin(x)}, , {\tt cos(x)}, {\tt tan(x)},
%{\tt exp(x)} (the exponential function), $\ldots$.
%
%Gnuplot can make plots not only from analytic functions, but also from data.
%Put the following data into a file and save it as ``data.txt''.
%
%\begin{verbatim}
%0.1     0.00316096 0.00537051
%0.05    0.00101441 0.00185594
%0.025   0.00025341 0.00048454
%0.0125  6.3341e-05 0.00012385
%0.00625 1.5834e-05 3.1312e-05
%\end{verbatim}
%
%As you can see the above data set has 3 columns. To make a plot of column 2
%vs column 1, while in the gnuplot command line simply type
%
%\begin{verbatim}
%p "data.txt" u 1:2 w l
%\end{verbatim}
%%
%and hit enter. Here in double quotation marks we place the name of the
%file ``u'' stands for ``using'', ``1:2'' stands for column 2 vs column
%1, so the first column that appears goes to the x-axis of the
%plot. The ``w l'' stands for ``with lines'', i.e., it connects the
%data points.  If you want to show the points alone use ``w p'' (with
%points), and if you want both points and lines use ``w lp'' (with
%line-points).
%
%We can also create a single plot that shows more than one curves, by
%separating with commas the other curves. We can use, e.g. the third
%column, as follows
%
%\begin{verbatim}
%p "data.txt" u 1:2 w l, "data.txt" u 1:3 w l
%\end{verbatim}
%
%The data here are very close to each other, so we need to take log
%scales, i.e.,
%
%\begin{verbatim}
%set log x; set log y; p "data.txt" u 1:2 w l, "data.txt" u 1:3 w l
%\end{verbatim}
%
%Let's also add labels to the axes
%
%\begin{verbatim}
%set log x; set log y; set xlabel "{/Symbol D} x"; set ylabel "Error";
%p "data.txt" u 1:2 w l, "data.txt" u 1:3 w l
%\end{verbatim}
%%
%where you can run the first line (i.e., hit enter), and then run the second line (hitting
%enter again). Here the construct {\tt \{/Symbol D\}} allows you to write Greek
%letters, the particular one is the upper case delta, i.e., $\Delta$. We can also add
%titles to the key (or legend) of the plot, by using the {\tt t} (title) operator as follows
%
%\begin{verbatim}
%set log x; set log y; set xlabel "{/Symbol D} x"; set ylabel "Error";
%p "data.txt" u 1:2 w l t "Approximation 1", "data.txt" u 1:3 w l t "Approximation 2"
%\end{verbatim}
%
%We can also add analytic functions to our plot, e.g.,
%
%\begin{verbatim}
%set log x; set log y; set xlabel "{/Symbol D} x"; set ylabel "Error";
%p "data.txt" u 1:2 w l t "Approximation 1", "data.txt" u 1:3 w l t "Approximation 2", 0.01*sin(x) w l
%\end{verbatim}
%%
%Notice that the legend is automatically set to the analytic function name.
%
%Once we are happy with how our plot looks, we can output it to a file. To do this we first
%decide the file type and set the filename. For example to output a pdf file type
%
%\begin{verbatim}
%set output "myplot.pdf"
%\end{verbatim}
%%
%where in double quotes you enter your filename with the corresponding extension.
%Then you need to set the terminal to be the corresponding one by typing
%%
%\begin{verbatim}
%set term pdf
%\end{verbatim}
%%
%and then finally either type
%\begin{verbatim}
%replot
%\end{verbatim}
%%
%if you have already seen the plot in the gnuplot x-terminal, or to be safe just type
%the whole command again, i.e.,
%\begin{verbatim}
%set log x; set log y; set xlabel "{/Symbol D} x"; set ylabel "Error";
%p "data.txt" u 1:2 w l t "Approximation 1", "data.txt" u 1:3 w l t "Approximation 2", 0.01*sin(x) w l
%\end{verbatim}
%%
%
%To exit gnuplot, either hit {\tt ctrl+D} or type $exit$ and hit enter. If the Greek letter is not rendered properly on the
%machine you first have to generate an eps file, and then convert it to pdf. This can be done by using the postscript terminal
%of gnuplot. To do this at the step where you set the output file name you type
%%
%\begin{verbatim}
%set output "myplot.eps"
%\end{verbatim}
%%
%where in double quotes you enter your filename with the corresponding extension.
%Then you need to set the terminal to be the corresponding one by typing
%%
%\begin{verbatim}
%set term post eps enhanced color
%\end{verbatim}
%%
%and finally replot
%%
%\begin{verbatim}
%set log x; set log y; set xlabel "{/Symbol D} x"; set ylabel "Error";
%p "data.txt" u 1:2 w l t "Approximation 1", "data.txt" u 1:3 w l t "Approximation 2", 0.01*sin(x) w l
%\end{verbatim}
%%
%where you can hit enter after the first line, and then continue onto a
%second line. All different commands can be in separate lines if you
%want. Hitting enter after the second line will give the file you want,
%and you can exit gnuplot. After generating the {\tt myplot.eps} file,
%you can convert it to pdf by using the linux {\tt ps2pdf} utility,
%i.e., typing
%%
%\begin{verbatim}
%ps2pdf -dEPSCrop myplot.eps
%\end{verbatim}
%
%To view the plot you can use the {\tt evince} utility, by typing
%{\tt evince myplot.eps} or {\tt evince myplot.pdf}. You can further
%convert the pdf plot to png or jpg by using the linux convert (imagemagic)
%utility. To convert to png run
%
%\begin{verbatim}
%convert -density 300 myplot.pdf myplot.png
%\end{verbatim}
%
%and to convert to jpg run
%
%\begin{verbatim}
%convert -density 300 myplot.pdf myplot.jpg
%\end{verbatim}
%
%
%\section{Makefiles}
%
%The Linux utility {\tt make} provides a convenient way for combining
%jobs/files that depend on other files. To drive {\tt make} we need a
%{\tt Makefile}. Most often, the {\tt Makefile} tells {\tt make} how to
%compile and link a program.
%
%A makefile consists of ``rules'' which have the following structure
%%
%\begin{verbatim}
%target ... : prerequisites ...
%        recipe
%        ...
%\end{verbatim}
%
%A {\tt target} can be the name of a file. Examples of targets are
%executable or object files.
%
%The {\tt prerequisites} are files used as input to generate the {\tt
%  target}. A {\tt target} can depend on several files.
%
%A {\tt recipe} is an action that {\tt make} executes.
%{\bf Note: you need to put a tab character at the beginning of every recipe!}
%
%
%Often a {\tt recipe} is in a {\tt rule} with {\tt prerequisites} and
%will generate a {\tt target} file if any of the {\tt prerequisites}
%change. This is extremely useful when compiling a very large code that
%contains multiple files, because using {\tt make} will recompile only
%those files that have changed.
%
%However, a {\tt rule} with a {\tt recipe} for a {\tt target} need not
%have {\tt prerequisites}. For example, a {\tt rule} containing the
%{\tt rm} command associated with a {\tt target} called ``clean'' does
%not have prerequisites.
%
%A simple example {\tt Makefile} would contain the following
%\begin{verbatim}
%
%myprogram : main.o utils.o
%            g++ -o myprogram main.o utils.o
%
%main.o : main.C header.h
%        g++ -c main.C
%
%utils.o : utils.C
%        g++ -c utils.C
%
%clean :
%        rm myprogram main.o utils.o
%
%\end{verbatim}
%
%If we have the files main.C, utils.C and header.h, and run {\tt make}
%in the same directory as the {\tt makefile}, the above makefile will
%then build the executable {\tt myprogram}. The flag ``-c'' is to just
%compile files, but not link them. If instead you type {\tt make clean},
%make will then remove the files myprogram, main.o, utils.o.
%
%In the above makefile, we have 4 targets that include the executable
%file {\tt myprogram}, and the object main.o, utils.o and the target
%{\tt clean}. The prerequisites for myprogram are main.o and utils.o
%which have their own prerequisites which are main.C, header.h and
%utils.C. A {\tt recipe} follows each line that contains a {\tt target}
%and {\tt prerequisites}, that simply compiles the relevant files.
%
%The target {\tt clean} is not a file, and all makefiles typically contain
%it for convenience.
%
%If we have a code that contains many files, it is far more convenient
%to use Variables to make our Makefiles simpler. Using variables the previous
%makefile can be simplified as follows
%\begin{verbatim}
%
%OBJS =  main.o utils.o
%cpp=g++
%cppflags= -c
%
%myprogram : ${OBJS}
%            ${cpp} -o myprogram ${OBJS}
%
%main.o : main.C myheader.h
%         ${cpp} ${cppflags} main.C
%
%utils.o : utils.C
%        ${cpp} ${cppflags} utils.C
%
%clean :
%        rm myprogram ${OBJS}
%
%\end{verbatim}
%
%The variable {\tt OBJS} above contains the object files our program
%depends on.  The variable {\tt cpp} is the compiler, and {\tt
%  cppflags} is the compiler flags we want to use. Everything else is
%basically the same and to use a variable we always put the variable
%name within curly brackets that follow a dollar sign: {\tt \$\{\}}. Using
%variables way we can simply change the compiler program, the flags,
%add more flags, such as compiler optimization flags, as well as
%add/remove more object files.
%
%\subsection{Compiling multiple programs with one Makefile}
%
%We can use one makefile to compile multiple programs.  For example
%lets assume that we have 3 programs. One program is in files
%program1.C header.h c utils.C, the second program is contained in file
%program2.C and the third in file program3.C. The following Makefile
%can compile these programs
%
%A simple example {\tt Makefile} would contain the following
%\begin{verbatim}
%
%# Target to compile all
%all: program1 program2 program3
%
%# Target for program in program1.C, utils.C and header.C.
%program1 : program1.o utils.o
%            g++ -o myprogram1 program1.o utils.o
%
%program1.o : program1.C header.h
%        g++ -c program1.C
%
%utils.o : utils.C
%        g++ -c utils.C
%
%# Target for program in program2.C
%program2 : program2.o
%            g++ -o program2 program2.o
%
%program2.o : program2.C
%        g++ -c program2.C
%
%# Target for program in program3.C
%program3 : program3.o
%            g++ -o program3 program3.o
%
%program3.o : program3.C
%        g++ -c program3.C
%
%clean :
%        rm program1 program2 program3 *.o
%
%\end{verbatim}
%
%The above Makefile compiles program1 if you type {\tt make program1},
%program2 if you type {\tt make program2}, program3 if you type {\tt
%  make program3}. It will compile all programs if you type {\tt make
%  all}. Finally, {\tt make clean} will remove the executables and all
%object files.
%
%
%
\end{document}
